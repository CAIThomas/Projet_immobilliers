# Import des biblioth√®ques n√©cessaires pour le scraping avec Selenium
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
from selenium.common.exceptions import NoSuchElementException, TimeoutException
import pandas as pd
import re
import time
import random

# Options pour Chrome
chrome_options = Options()
chrome_options.add_experimental_option('detach', True)  # Garder la fen√™tre ouverte apr√®s l'ex√©cution du script
chrome_options.add_argument("start-maximized")  # Lancer le navigateur en mode maximis√©
chrome_options.add_argument("--incognito")  # Mode incognito pour √©viter les cookies persistants
chrome_options.add_experimental_option('excludeSwitches', ['enable-logging'])  # Exclure les logs inutiles de Chrome

# D√©marrer WebDriver avec Chrome et configuration des options
service = Service(ChromeDriverManager().install())  # Installer automatiquement le driver Chrome
driver = webdriver.Chrome(service=service, options=chrome_options)  # Lancer le navigateur avec ces options

# URL de la page de recherche des annonces immobili√®res sur Logic-Immo
base_url = "https://www.logic-immo.com/classified-search?distributionTypes=Buy,Buy_Auction&estateTypes=Apartment&locations=AD06FR95&projectTypes=New_Build,Resale"
search_url = f"{base_url}&m=homepage_new_search_classified_search_result"
driver.get(search_url)  # Ouvrir la page

# ------------------------------------------ FONCTIONS ---------------------------------------------------------
# Fonction pour accepter les cookies
def accept_cookies():
    try:
        iframes = driver.find_elements(By.TAG_NAME, "iframe")  # Cherche les iframes sur la page
        for iframe in iframes:
            driver.switch_to.frame(iframe)  # Passe dans l'iframe pour interagir avec ses √©l√©ments
            try:
                accept_button = WebDriverWait(driver, 3).until(EC.element_to_be_clickable((By.ID, "didomi-notice-agree-button")))  # Attendre que le bouton "Accepter" soit cliquable
                accept_button.click()  # Cliquer sur le bouton "Accepter"
                break  # Si un bouton est trouv√© et cliqu√©, sortir de la boucle
            except:
                driver.switch_to.default_content()  # Retourner au contenu principal si le bouton n'est pas trouv√© dans l'iframe

        # Attendre et cliquer sur le bouton "Accepter" si n√©cessaire
        accept_button = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.ID, "didomi-notice-agree-button")))
        accept_button.click()

    except Exception as e:
        print(f"‚ùå Impossible de cliquer sur 'TOUT ACCEPTER' : {e}")  # G√©rer les erreurs


# Fonction pour obtenir la superficie du salon
def get_superficie_salon():
    try:
        spans = driver.find_elements(By.XPATH, "//span[@class='css-1az3ztj']")  # Trouver les √©l√©ments de superficie
        for span in spans:
            texte = span.text.strip().lower()  # Nettoyer le texte
            if texte.startswith("salon") and "m¬≤" in texte:  # V√©rifier si c'est la superficie du salon
                match = re.search(r'(\d+[\.,]?\d*)\s*m\u00b2', texte)  # Utiliser une expression r√©guli√®re pour extraire la superficie
                if match:
                    superficie = match.group(1).replace(',', '.')  # Remplacer les virgules par des points pour avoir un format d√©cimal
                    return float(superficie)  # Retourner la superficie sous forme de nombre d√©cimal
        return None
    except Exception as e:
        print("‚ùå Erreur dans get_superficie_salon:", str(e))
        return None  # Retourner None en cas d'erreur

# Fonction pour obtenir l'exposition de l'appartement
def get_exposition():
    try:
        spans = driver.find_elements(By.XPATH, "//span[@class='css-1az3ztj']")  # Trouver les √©l√©ments de l'exposition
        for span in spans:
            texte = span.text.strip().lower()  # Nettoyer le texte
            if texte.startswith("exposition"):  # V√©rifier si le texte concerne l'exposition
                exposition = texte.replace("exposition", "").strip()  # Extraire l'exposition
                return exposition.capitalize() if exposition else None  # Retourner l'exposition avec une majuscule
        return None
    except Exception as e:
        print("‚ùå Erreur dans get_exposition:", str(e))
        return None  # Retourner None en cas d'erreur


# Fonction pour v√©rifier les caract√©ristiques (balcon, ascenseur, etc.)
def check_caracteristique(nom_equipement):
    try:
        nom_equipement = nom_equipement.lower()

        # Attendre que le bloc de caract√©ristiques soit pr√©sent
        WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.XPATH, "//div[@id and contains(@id,'react-aria')]/div[2]/div"))
        )

        # R√©cup√©rer tous les spans visibles dans la bo√Æte
        spans = driver.find_elements(By.XPATH, "//div[@id and contains(@id,'react-aria')]/div[2]/div//ul/li/div/span")
        textes_caracteristiques = [span.text.strip().lower() for span in spans if span.text.strip()]

        # Liste de mots/expressions √† d√©tecter comme n√©gation
        mots_negatifs = ["pas de","aucun", "aucune", "non", "pas", "ne dispose pas", "ne comporte pas"]

        for texte in textes_caracteristiques:
            if nom_equipement in texte:
                if any(mot in texte for mot in mots_negatifs):
                    return "Non"
                else:
                    return "Oui"

        return "Non"

    except Exception as e:
        print("‚ùå Erreur dans check_caracteristique :", str(e))
        return "Non"

    
def fallback_check_caracteristique(nom_equipement):
    try:
        nom_equipement = nom_equipement.lower()
        spans = driver.find_elements(By.XPATH, "//span[@class='css-1az3ztj']")
        for span in spans:
            texte = span.text.strip().lower()
            if nom_equipement in texte:
                return "Non" if "pas" in texte else "Oui"
        return "Non"
    except Exception as e:
        print("Erreur dans fallback_check_caracteristique:", str(e))
        return "Non"



# ---------------------------------- SCRAPING --------------------------------------------------------
accept_cookies()  # Appeler la fonction pour accepter les cookies

# Variables initiales
original_window = driver.current_window_handle  # Garde la r√©f√©rence de la fen√™tre principale
data = []  # Liste pour stocker les donn√©es r√©cup√©r√©es
current_page = 1 # Num√©ro de la page actuelle pour la navigation
max_pages = 400# Nombre maximal de pages √† scraper

# Boucle principale pour parcourir les pages
while current_page <= max_pages:
    driver.get(f"{base_url}&page={current_page}")  # Acc√©der √† la page de r√©sultats
    try:
        driver.find_element(By.XPATH, "//*[contains(text(), 'Aucun r√©sultat')]")  # V√©rifier s'il n'y a aucun r√©sultat
        break
    except NoSuchElementException:
        pass  # Si l'√©l√©ment n'est pas trouv√©, continuer

    time.sleep(random.uniform(1.5, 3.0))  # Attendre entre les actions pour simuler un comportement humain
    index = 0  # Initialiser l'index des annonces

    while True:
        annonces = driver.find_elements(By.XPATH, '//*[@id="root"]/div/div[3]/div[1]/div[4]/div/div')  # Trouver toutes les annonces sur la page
        if index >= len(annonces):  # Si l'index d√©passe le nombre d'annonces, sortir
            break

        try:
            WebDriverWait(driver, 10).until(EC.element_to_be_clickable(annonces[index]))  # Attendre que l'annonce soit cliquable
            annonces[index].click()  # Cliquer sur l'annonce
            WebDriverWait(driver, 10).until(EC.number_of_windows_to_be(2))  # Attendre l'ouverture d'une nouvelle fen√™tre
            new_window = [w for w in driver.window_handles if w != original_window][0]  # Trouver la nouvelle fen√™tre
            driver.switch_to.window(new_window)  # Passer √† la nouvelle fen√™tre

            if not driver.current_url.startswith("https://www.logic-immo.com/detail-vente-"):  # V√©rifier si l'URL correspond √† une annonce valide
                driver.close()  # Fermer la fen√™tre
                driver.switch_to.window(original_window)  # Retourner √† la fen√™tre principale
                index += 1  # Passer √† l'annonce suivante
                continue

            # Initialiser les variables pour les caract√©ristiques
            pieces = superficie = superficie_salon = etage = nombre_etages = prix = arrondissement = charges_annuelles = exposition = None
            balcon = ascenseur = parking = cave = accessible_mobilit√©_r√©duite = "Non"
            interphone = alarme = digicode = gardien = "Non"
            Cuisine_ouverte = sans_vis_√†_vis = calme = "Non"
            chambres = 1  # Nombre de chambres par d√©faut

            # ----------------------------- carat√©ristique de base ---------------------------------------------------
            # Extraire les caract√©ristiques de base comme le nombre de pi√®ces, la superficie, etc.
            caracteristiques_elements = driver.find_elements(By.XPATH, "//div[@class='css-j7qwjs']")
            for elem in caracteristiques_elements:
                try:
                    valeur = elem.find_element(By.CLASS_NAME, "css-1nxshv1").text
                    nom = elem.find_element(By.CLASS_NAME, "css-15ctory").text.lower()
                    if nom in ["pi√®ce", "pi√®ces"]:
                        pieces = valeur
                    elif nom in ["chambre", "chambres"]:
                        chambres = valeur
                    elif nom == "superficie":
                        superficie = valeur
                    elif nom == "√©tage":
                        match = re.search(r'(\d+)/(\d+)', valeur)
                        if match:
                            etage, nombre_etages = match.groups()
                        else:
                            etage = valeur
                except:
                    continue

            # Extraire le prix, l'arrondissement et les charges annuelles
            try:
                prix = driver.find_element(By.XPATH, "//span[@data-testid='aviv.CDP.Sections.Hardfacts.Price.Value']").text.strip()
                prix = prix.replace('√¢‚Ç¨¬Ø', ' ').replace('√¢‚Äö¬¨', '‚Ç¨')  # Nettoyer le prix
            except:
                prix = None  # Si aucune donn√©e trouv√©e, assigner None

            try:
                arrondissement = driver.find_element(By.XPATH, "//span[contains(@style, 'white-space:nowrap')]").text.strip()
            except:
                arrondissement = None

            try:
                charges_annuelles = driver.find_element(By.XPATH, "//span[contains(@class, 'css-1thfuam') and contains(text(), '‚Ç¨/an')]").text.strip()
                charges_annuelles = charges_annuelles.replace('√¢‚Ç¨¬Ø', ' ').replace('&nbsp;', ' ')
            except:
                charges_annuelles = None

            # -------------------------- Recherche du DPE et GES ---------------------------------------
            try:
                energy_elements = driver.find_elements(By.XPATH, "//div[@data-testid='aviv.CDP.Sections.Energy.Preview.EfficiencyClass']")
                
                if len(energy_elements) >= 2:
                    dpe = energy_elements[0].text.strip()
                    ges = energy_elements[1].text.strip()
                    print(f"üå° DPE trouv√© : {dpe}")
                    print(f"üåç GES trouv√© : {ges}")
                else:
                    dpe, ges = None, None
                    print("‚ùå Pas assez d'infos pour DPE et GES.")
            except Exception as e:
                dpe, ges = None, None
                print(f"‚ùå Erreur lors de la r√©cup√©ration DPE/GES : {e}")



            # -------------------------- R√©cup√©ration des autres caract√©ristiques ------------------------
            try:
                voir_caracteristiques = WebDriverWait(driver, 5).until(
                    EC.element_to_be_clickable((By.XPATH, "//span[@class='css-1gur7lg' and contains(text(), 'Voir les')]"))
                )
                voir_caracteristiques.click()
                time.sleep(2)
                check_fn = check_caracteristique
            except:
                print("‚ö† Bouton 'Voir les caract√©ristiques' non trouv√©. Utilisation du fallback.")
                check_fn = fallback_check_caracteristique

            balcon = check_fn("Balcon")
            ascenseur = check_fn("Ascenseur")
            parking = check_fn("Parking")
            cave = check_fn("Cave")
            accessible_mobilit√©_r√©duite = check_fn("Acc√®s mobilit√© r√©duite")
            interphone = check_fn("Interphone")
            alarme = check_fn("Alarme")
            digicode = check_fn("Digicode")
            gardien = check_fn("Gardien")
            Cuisine_ouverte = check_fn("Cuisine ouverte")
            sans_vis_√†_vis = check_fn("Sans vis-√†-vis")
            calme = check_fn("Calme")


            # Extraire la superficie du salon et l'exposition
            superficie_salon = get_superficie_salon()
            exposition = get_exposition()

            # Ajouter les donn√©es extraites √† la liste data
            data.append([prix, arrondissement, pieces, chambres, superficie, superficie_salon, etage, nombre_etages,
                         balcon, ascenseur, parking, cave, accessible_mobilit√©_r√©duite, interphone, alarme,
                         digicode, gardien, Cuisine_ouverte, sans_vis_√†_vis, calme, charges_annuelles, exposition, dpe, ges])

            driver.close()  # Fermer la fen√™tre de l'annonce
            driver.switch_to.window(original_window)  # Retourner √† la fen√™tre principale
            WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.XPATH, '//*[@id="root"]/div/div[3]/div[1]/div[4]')))  # Attendre la rechargement
            index += 1  # Passer √† l'annonce suivante

        except Exception as e:
            print(f"‚ùå Erreur avec l'annonce {index + 1} : {e}")
            index += 1  # Passer √† l'annonce suivante

    current_page += 1  # Passer √† la page suivante

    # Sauvegarde interm√©diaire toutes les 10 pages
    if current_page % 10 == 0:
        try:
            df_temp = pd.DataFrame(data, columns=[
                "Prix", "Arrondissement", "Nombre de pieces", "Nombre de chambres", "Superficie", "Superficie salon (m¬≤)",
                "Etage", "Nombre d'etages", "Balcon", "Ascenseur", "Parking", "Cave", "Accessible_mobilit√©_r√©duite",
                "Interphone", "Alarme", "Digicode", "Gardien", "Cuisine ouverte", "Sans vis √† vis", "Calme",
                "Charge annuelles", "Exposition", "DPE", "GES"
            ])
            df_temp.to_csv(f"annonces_94_{current_page}.csv", index=False, encoding="utf-8", sep=";")
            print(f"üíæ Sauvegarde interm√©diaire : annonces_94_{current_page}.csv")
        except Exception as e:
            print(f"‚ö† Erreur lors de la sauvegarde interm√©diaire page {current_page} : {e}")



# Fermer le navigateur √† la fin du scraping
driver.quit()



# Sauvegarder les donn√©es dans un fichier CSV
df = pd.DataFrame(data, columns= ["Prix", "Arrondissement", "Nombre de pieces", "Nombre de chambres", "Superficie", "Superficie salon (m¬≤)",
           "Etage", "Nombre d'etages", "Balcon", "Ascenseur", "Parking", "Cave", "Accessible_mobilit√©_r√©duite",
           "Interphone", "Alarme", "Digicode", "Gardien", "Cuisine ouverte", "Sans vis √† vis", "Calme",
           "Charge annuelles", "Exposition","DPE","GES"])

df.to_csv("annonces_94.csv", index=False, encoding="utf-8", sep=";")

print("üìÇ Fichier 'annonces_logic_immo.csv' sauvegard√© avec succ√®s ! üéâ")
